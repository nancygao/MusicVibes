<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Music Vibes</title>
    <style>
    	* { padding: 0; margin: 0; }
    	canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>


<audio autoplay="autoplay" controls loop style="display:none;">
     <source src="http://www.televisiontunes.com/uploads/audio/Star%20Wars.mp3" />     
 </audio>

	 <canvas id="myCanvas" style="background-image:url('http://www.wallpapercave.com/wp/kSQdCxM.jpg');
							 background-size: cover;"></canvas> 



<script>

	//global constants
	var RAD = Math.PI/180;
	var KEY_SET = ["L", "U", "R", "D"]
	var KEY_MAPPING = { 37:"L", 38:"U", 39:"R", 40:"D"};

	//fetch and adjust canvas context, also bind keylisteners and difficulty setting
	var canvas = document.getElementById("myCanvas");
	var ctx = canvas.getContext("2d");
	ctx.canvas.width  = window.innerWidth;
	ctx.canvas.height = window.innerHeight;
	document.addEventListener("keyup", destroyAsteroidAttempt, false);
	var current_difficulty = 10; //10 is the easiest and 1 is the hardest
	var score = 0;

	//fetching asteroid image and caching to decrease latency
	var asteroid = new Image();
	var is_asteroid_cached = false;
	var fire = new Image();

	asteroid.onload = function() {
		if(!is_asteroid_cached){
			fire.onload = function() {
				is_asteroid_cached = true;
				startMainRoutine();
				setSpawnRate();
			}
		}
	}

	asteroid.src = "asteroid.png";
	fire.src = "explosion.png";



	//set boundary for asteroid detection
	var asteroid_y_boundary = ctx.canvas.height*0.92;

	//setting asteroid attributes and abstractions
	var sequences_until_explosion = 10;
	var dy = asteroid_y_boundary/sequences_until_explosion;
	var asteroid_width = 50;
	var asteroid_height = 50;
	var asteroid_radius = 20;
	var current_rotation_degrees = 0;
	//Falling asteroid class
	FallingAsteroid = function(prop){
      this.x = rand(ctx.canvas.width*.05, ctx.canvas.width*.95);
      this.y = 0;
      this.isDestroyed = false;
      this.h = asteroid_height;
      this.w = asteroid_width;
      this.angle = rand(0, 360);
      this.speed = rand(1, 1);
      this.letter = KEY_SET[rand(0,3)];
      this.asteroid_image = asteroid;
      return this;
    };

	FallingAsteroid.prototype.drop = function() {
	  // Manipulate Icon properties
	  if(this.y > asteroid_y_boundary) { // (if has dropped)
	  	//THIS IS WHERE ALL VIBRATORS SHOULD BE RELEASED AND WE INFORM THE USER THAT THE GAME IS OVER
	  	alert("game over! :(");
	    this.y = 0; // restart from top
	    this.x = rand(ctx.canvas.width*.05, ctx.canvas.width*.95); // new X position
	    this.speed = rand(1, 4); // new random speed
	  }
	  this.y += this.speed;
	  this.angle += this.speed % 360;

	  // Manipulate context 
	  ctx.save();                    // save context
	  ctx.translate(this.x, this.y); // move to point
	  ctx.rotate(this.angle * RAD);  // rotate around that point
	  ctx.drawImage(this.asteroid_image, -(this.asteroid_image.width/2), -(this.asteroid_image.height/2));
	  ctx.restore();

	  ctx.save();
	  ctx.translate(this.x, this.y);
	  ctx.font = "40pt Calibri";
      ctx.fillText(this.letter, 0, 0);
      ctx.restore();
	};

	//set of all active asteroids
	var asteroids = [];


	function spawnNewAsteroid() {
		newFallingAsteroid = new FallingAsteroid();
		callArduinoMotor(newFallingAsteroid.letter);
		asteroids.push(newFallingAsteroid);
	}


	function callArduinoMotor(letter) {


		//opened server on {"address":"127.0.0.1","family":"IPv4","port":1337}

		switch (letter) {
			case "L":

				break;
		}
	}

	//random number generator
	function rand(min,max) {
  		return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	function drawBoundary() {
		ctx.beginPath();
		ctx.rect(0, asteroid_y_boundary, ctx.canvas.width, asteroid_y_boundary*.03);
		ctx.fillStyle = "#FFFFFF";
		ctx.fill();
		ctx.closePath();
	}

	function drawScore() {
		ctx.beginPath();
		ctx.rect(ctx.canvas.width*.02, asteroid_y_boundary*.05, 
			ctx.canvas.width*.15, asteroid_y_boundary*.1);
		ctx.fillStyle = "#86A7C4";

		ctx.fill();
		ctx.closePath();
		ctx.save();
		ctx.fillStyle = "#FFF";
		ctx.font = "20pt Calibri";
		ctx.strokeStyle = "#000";
		ctx.textBaseline = "top";
		ctx.lineWidth = 0.1;
	    ctx.fillText("Score: " + score , ctx.canvas.width*.05, asteroid_y_boundary*.06);
	    ctx.restore();
	    ctx.fillStyle = "#FFF";
	}

	function drawFire(targetAsteroid) {
		ctx.save(); 
		ctx.beginPath();
		ctx.drawImage(fire, targetAsteroid.x, targetAsteroid.y, targetAsteroid.w*3, targetAsteroid.h*3);
		ctx.fill();
		ctx.closePath();
		setTimeout(eraseExplosion, 500, targetAsteroid);
		ctx.restore();
	}

	function eraseExplosion(targetAsteroid) {
		ctx.clearRect(targetAsteroid.x, targetAsteroid.y, targetAsteroid.w*2, targetAsteroid.h*2);
		var targetDeletion = -1;
		for(i in asteroids) {
			if(targetAsteroid == asteroids[i]) {
				targetDeletion = i;
				break;
			}
		}

		if(targetDeletion != -1) {
			asteroids.splice(targetDeletion, 1);
		}
	}

	//main game thread
	function startMainRoutine() {
		(function gameLoop() { 
		  redraw();
		  requestAnimationFrame(gameLoop);
		}());
	}


	//redraws the entire canvas scene and increments the drop of the asteroid by one
	function redraw() {
		ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); 
		drawBoundary();
		drawScore();
		var deletedAsteroids = -1;
		for(i in asteroids) {
			if(!asteroids[i].isDestroyed) {
				asteroids[i].drop();
			} else {
				var targetAsteroid = asteroids[i];
				drawFire(targetAsteroid);
				deletedAsteroids = i;
			}
		}
	}


	//listen to key press and attempt to destroy incoming asteroids
	function destroyAsteroidAttempt(e) {
		var letterPressed = KEY_MAPPING[e.keyCode];
		if(letterPressed != null) {
			var letter_asteroid_collisions;

			for(i in asteroids) {
				if(asteroids[i].letter == letterPressed && !asteroids[i].isDestroyed) {
					asteroids[i].isDestroyed = true;
					score+=1
					break;
				}

			}

			//redraw();
		}

	}

	var spawn_interval;
	var difficulty_increase_interval;
	var base_increase_time = 5000;

	//difficulty controller
	function setSpawnRate() {
		spawn_interval = setInterval(spawnNewAsteroid, 500*current_difficulty);
		difficulty_increase_interval = setInterval(increaseDifficulty, base_increase_time);
	}

	//increases the difficulty
	function increaseDifficulty() {
		clearInterval(spawn_interval);
		clearInterval(difficulty_increase_interval);
		current_difficulty -= 1;
		spawn_interval = setInterval(spawnNewAsteroid, 500*(current_difficulty+.5));
		base_increase_time *= 1.5;
		difficulty_increase_interval = setInterval(increaseDifficulty, base_increase_time);
	}
	
</script>

</body>
</html>